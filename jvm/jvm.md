#### 字节码 

- 我们平时说的java字节码，指的是用java语言编译成的字节码。准确的说任何能在jvm平台上执行的字节码格式都是一样的。所以应该统称为jvm字节码。（只要生成的字节码符合jvm归规范，就都能再jvm运行）
- 不同的编译器，可以编译出相同的字节码文件，字节码文件也可以在不同的jvm上运行。
- java虚拟机和java语言并没有必然的联系，他只与特定的二进制文件格式--class文件格式所关联，class文件中包含了java虚拟机指令集（或者称为字节码、bytecodes）和符号表，还有一些其他辅助信息。



#### 多语言混合编程

​		Java平台上的多语言混合编程正成为主流，通过特定领域的语言去解决特定领域的问题是当前软件开发应对日趋复杂的项目需求的一个方向。

​		试想一下，在一个项目中，并行处理用Clojure语言编写，展示层用JRuby/Rails，中间层则是Java，每个应用层都将使用不同的编程语言来完成，而且，接口对每一层的开发者都是透明的，各种语言之间的交互不存在任何困难，就像是用自己语言的原生API一样方便，因为他们最终都会运行在一个虚拟机之上。！





Jvm本身并没有和硬件做直接交互。

jdk

- 提供java语言编写，api调用等。
- jre 包括各种运行时环境，jvm。





#### JVM的架构模型

Java编辑器输入的指令流基本上是一种**基于栈的指令集架构**，另外一种指令集架构则是**基于寄存器的指令集架构**。

- 基于栈式架构的特点
  - 设计和实现更简单，适用于资源受限的系统。（嵌入式）
  - 避开了寄存器的分配难题：使用零地址指令方式分配。（一地址指令即有一个地址，有一个操作数。而零地址只有一个操作数，在栈顶就不用地址了）
  - 指令流中的指令大部分是零地址指令，其执行过程依赖于操作栈。指令集更小，编辑器容易实现。（零地址指令  8位）
  - 不需要硬件支持，可移植性更好，更好实现跨平台。
- 基于寄存器架构特点   
  - 典型的应用是x86的二进制指令集：比如传统的pc以及android的davlik虚拟机。
  - 指令集架构则完全依赖于硬件，可以执行差。
  - 性能优秀和执行更高效。
  - 花费更少指令去完成一项操作。
  - 大部分情况下，基于寄存器架构的指令集往往都以一地址指令、二地址指令、三地址指令为主，而基于栈式架构的指令集却是以零地址指令为主。   （一地址指令  16位）



#### JVM生命周期

- 虚拟机的启动：Java虚拟机的启动通过类引导加载器（bootstrap class loader）创建一个初始类（initial class）来完成的，这个类是由虚拟机的具体暂时先指定的。

- 虚拟机的执行

  - 一个运行中的Java虚拟机有一个清晰的任务：执行Java程序

  - 程序开始执行时他才运行，程序结束时他就停止。
  - 执行一个所谓的Java程序的时候，正真在执行的是一个叫做java虚拟机的进程。

- 虚拟机的退出

  - 程序正常执行结束
  - 程序执行过程中遇到异常或错误而异常终止。
  - 由于操作系统出现错误而导致了Java虚拟机进程终止
  - 某线程调用了Runtime类或System类的exit方法，或Runtime类的halt方法，并且Java安全管理器也允许这次exit或halt操作
  - 除此之外，JNI（Java Native Interface）规范描述了用JNI Invocation Api 来加载或卸载Java虚拟机时，java虚拟机推出的情况







### 类加载器子系统作用

- 类加载器子系统负责从文件系统或者网络中加载class文件，class文件在文件开头有特定的文件标识。
- ClassLoader只负责class文件的加载，至于他是否可以运行，运行时是否报错，则有Execution Engine决定。（执行引擎）即ClassLoader只负责把class文件加载到内存里边，怎么运行的都不关他事。
- 加载的类信息存放于一块成为方法区的内存空间。除了类的信息外，方法区中还会存放运行时常量池的信息，可能还包括字符串字面量和数字常量(这部分常量信息是class文件中常量池部分的内存映射)



#### 类的加载过程

```java
public class Hello{
    public static void main(String[] args){
        sout("heihei");
    }
}
```

- 装载类Hello了吗
  - N:  ClassLoader装载顺利
    - N：抛出异常
    - Y：continue
  - Y： 链接
  - 初始化Hello
  - 调用Hello.main
  - 结束

简单说就是首先检查Hello有没有转载，没有装载就是用classLoader进行转载，失败则抛出异常，成功则开始链接，初始化Hello，调用Hello.main。若 Hello已经转载，则开始链接，初始化Hello，调用Hello.main。



总结一下总共由3步

- 加载
  - 通过一个类的全限定名获取定义此类的二进制字节流
  - 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构(1.7以前叫方法区，1.7以后叫源数据)
  - **在内存中生成一个代表这个类的java.lang.Class对象**，作为方法去这个类的各种数据的访问入口。
  
- 链接
  - 验证(verify)
    - 目的是确保class文件的字节流中包含的信息是否符合虚拟机要求，保证被加载类的正确性，不会危害虚拟机。
    - 主要有四纵验证方式：文件格式验证，元数据验证，字节码验证，符号引用验证
  - 准备(prepare)
    - 为类变量分配内存并且设置该类变量的默认初始值，即零值.(int 0等等)。此时还在准备阶段，并不是初始化阶段。(类变量就是静态变量)
    - 这里不包含用final修饰的static，因为final在编译的时候就会分配了(内存)，准备阶段会显示初始化。
    - 这里不会为实例变量分配初始化，类变量会分配再方法区中，而实例变量会随着对象一起分配到Java堆中。
  - 解析(resolve)
    - 将常量池的符号引用转换为直接应用的过程
    - 事实上，解析操作往往会伴随着JVM在执行完初始化之后再执行。
    - 符号引用就是一组符号来描述引用的目标。直接引用就是直接指向目标的指针、相对偏移量或一个简介定位到目标的句柄。
    - 解析动作主要针对类后接口、字段、类方法、接口方法、方法类型等。
  
- 初始化

  - **初始化阶段就是执行类构造器方法<clinit>()的过程**

  - 这个方法不需要自己定义，时javac编译器自动收集类中类变量所有赋值动作和静态代码块中的语句合并而来。   (即static变量的赋值和static静态代码块)

  - 类构造器方法会按照语句的顺序执行。

  - <clinit>()不同于类的构造器。（构造器时虚拟机虚的<init>()）

  - 若该类拥有父类，虚拟机会保证先执行父类的<clinit>()

  - 虚拟机必须保证一个类的<clinit>()必须在多线程环境加锁。即若有多个线程同时初始化一个类，最先初始化这个类的线程会加锁，他没有初始化完，别的类也没法初始化。

    ```java
    package com.flyingdigital;
    
    public class ThreadTest {
        public static void main(String[] args) {
            Runnable r = ()->{
                System.out.println(Thread.currentThread().getName()+"开始执行");
                DeadClass d = new DeadClass();
                System.out.println(Thread.currentThread().getName()+"执行结束");
            };
    
            (new Thread(r,"A")).start();
            (new Thread(r,"B")).start();
        }
    }
    
    
    // 无限死循环
    class DeadClass{
        public DeadClass(){
            if(true){
                System.out.println("i am thread"+Thread.currentThread().getName());
                while(true){
    
                }
            }
        }
    }
    
    ```

    

#### 类加载器

- 引导类加载器(BootstrapClassLoader)
  - 这个类加载使用C/C++编写，嵌套在jvm内部
  - 它用来加载java核心库（rt.jar等等）
  - 它并不继承ClassLoader，没有父加载器
  - 加载扩展类和应用程序类（系统类）加载器，并制定为他们的父加载器
  - 处于安全考虑，bootstrap只加载java，javax，sundd等开头的类
- 扩展类加载器(ExtClassLoader)
  - java语言编写，sun.misc.Launcher$ExtClassLoader实现
  - 派生于ClassLoader
  - 从java.ext.dirs系统属性指定的目录加载文类库，或从JDK的安装目录的jre/lib/ext子目录下的类
- 系统类加载器(应用程序类加载器AppClassLoader)：加载用户自定义的类
  - java语言编写，sun.misc.Launcher$AppClassLoader实现
  - 派生于ClassLoader
  - 父加载器为扩展类加载器
  - 他负责加载环境变量classpath或系统该属性java.class.path指定的类库
  - 该类加载是程序中默认的类加载器，一般来说，自定义的类都由它来加载
  - 可由ClassLoader.getSystemClassLoader获取该类加载器



#### 双亲委派机制

- 如果一个类加载器收到了类加载请求，他并不会自己先去加载，而是把这个请求委托个父类的加载器去执行。
- 如果父类加载器还存在父类加载器，那么继续向上委托，一次递归，请求最终将达到顶层的启动类加载器。
- 如果父类加载器可以完成类加载任务，就成功返回，若类加载器无法完成类加载，子加载器才会尝试自己去加载。

一个有意思问题: 我自己定义了一个`java.lang`的包，在这个包下定义了`String`类，在另以个包定义一个`StringTest`作为主类去加载自定义的String，但是按照双亲委派机制，请求向上委托到启动类加载器，启动类加载器可以完成加载，直接返回核心类库的String。

优势：

- 防止类重复加载
- 防止随意修改核心api

- 保护源代码   沙箱安全机制





### 运行时数据区(Runtime data area)

- 程序计数器(PC寄存器)
- 虚拟机栈
- 本地方法栈
- 堆
- 方法区

#### 线程

- 线程是一个程序里的运行单元。jvm运行一个应用程序有多个线程并行执行。
- 在Hotspot JVM中，每个线程都与操作系统的本地线程一一映射。
  - 当一个java线程准备好执行后，一个操作系统的本的线程也同时创建。java线程终止后，本地线程也会被回收。
- 操作系统负责所有线程的安排调度到任何一个可用的cpu上，一旦本地线程初始化成功，他就会调用java线程的run方法。



#### 程序计数器(Program Counter Register)

- 它是一块很小的内存空间，几乎可以忽略不计，它是运行速度最快的存储区域。(只存下一条指令的地址)
- **在jvm规范中，每个线程都有它自己的程序计数器**，它们的生命周期与线程的生命周期保持一致。
- 任何时间一个线程只有一个方法在执行，也就是虽为的**当前方法**。程序计数器会存储当前线程正在执行的java方法的jvm指令地址。
- 它在唯一在jvm中没有OutOfMemoryError情况的区域。

jvm中的程序计数寄存器中，Resigter的命名源于cpu的寄存器，寄存器存储指令相关的现场信息。cpu只有把数据装载到寄存器才能够运行。

这里，并非是广义上所指的物理寄存器，或许将其翻译为Pc计数器会会更加贴切(也称程序钩子)，并且也不容易引起一些不必要的误会。**jvm中的pc寄存器是对物理pc寄存器的一种抽象模拟**



**作用**：

​		pc寄存器用来存当前线程指令的地址。有执行引擎读取下一条指令。(简单来说就是存下一条指令的地址)字节码解释器可以改变程序计数器值来选取下一条需要执行的字节码指令。



示例：

```java
// 源代码
package com.flyingdigital;

public class PCRegisterTest {
    public static void main(String[] args) {
        int i = 0 ;
        int j = 10;
        int k = i + j;
    }
}

// 反编译后
0: iconst_0
1: istore_1
2: bipush        10
4: istore_2
5: iload_1
6: iload_2
7: iadd
8: istore_3
9: return

    
/*
 * 	在指令前边的 0-9是内存的相对偏移量，它们就是PC寄存器存的地址
 */
```

Q&A

Q:PC寄存器有什么好处？

A:它可以存出当前线程的下一条指令的地址，避免CPU来回切换线程而找不着执行指令。

Q:为什么PC寄存器线程私有？

A:若PC寄存器线程公用一个，那么在多线程环境下，第一个线程切换到第二个线城时，PC寄存器中地址为5，但我实际想执行的并不是地址为5的指令，这就会造成问题，所以PC寄存器还是每一个线程都有一个比较好。



#### 虚拟机栈

- Java虚拟机栈(java virture machine stack), 早期也叫java栈，每个线程创建时都会创建一个虚拟机栈，其内部保存一个个栈帧，每个栈帧对应一个方法。(栈帧时虚拟机栈的基本单位)位于顶部的栈帧就是当前方法。
- 生命周期与线程一致。
- 主管java程序运行，他保存方法的局部变量、部分结果，参与方法的调用和返回。

**优点**

- 访问速度仅次于PC寄存器。
- 操作只有入栈和出栈两种
- 对于栈来说不存在垃圾回收问题





> GC 垃圾回收
>
> OOM  outofmemory  内存溢出

**运行原理**

- 不同线程的栈是不能相互引用的。即不能在一个栈帧中引用另一个栈的栈帧。
- 如果当前方法调用了其他方法，方法返回之际，当前栈帧会返回此方法的执行结果给前一个栈帧，接着虚拟机会丢弃当前栈帧，使前一个栈帧成为当前栈帧。
- java方法有两种返回函数方式，一是正常返回（包括try/catch），而是抛出异常。这两种方法都会使栈帧出栈。

**每一个栈帧的结构**

- 局部变量表（Local Variables）

  - 局部变量表也叫局部变量数组或本地变量表
  - **定义为一个数字数组，主要用于存储方法参数和定义在方法里的局部变量**，包括基本数据类型，对象引用等
  - 局部变量表的大小是由编译时确定下来的，并保存在方法的Code属性的Maximun local variables数据项中。方法运行期间不可改变其大小。
  - 局部变量表中的变量只在当前方法调用中有效，方法调用结束，方法栈帧的弹出，局部标量表也随之摧毁。

  **Slot的理解**

  - 参数值的存放总是在局部变量数组的index0开始，到数组长度为-1处结束。

  - 局部变量表最基本的存储单元是Slot（变量槽）

  - 局部变量表中存放编译期可知的各种基本数据类型，引用类型等变量。

  - 局部变量表中，32为以内的类型只占一个slot，64位的类型(long、double)占用两个slot。

  - jvm会为每一个slot分配一个访问索引，通过这个索引即可访问到局部变量表中指定的局部变量。

  - 当一个实例方法被调用时，他的方法参数和方法体内部定义的局部变量会按照顺序被复制到局部变量表中的每一个slot中。

  - **如果需要访问局部变量表中一个64bit的局部变量，只需访问前一个索引即可**(eg: 若一个long类型占据34两个索引，访问3这个索引即可)

  - **如果当前栈帧是实例方法或构造器，那么jvm会自动在局部变量表的0处索引加上this变量**，这也是为什么static标记的方法不能使用this的原因。

  - 栈帧中的局部变量表中槽位是可以重用的

    ```java
    // 代码块中的局部变量作用域过期，那么就可以被重用
    public static void test(){
        PCRegisterTest pcRegisterTest = new PCRegisterTest();
        Date date = new Date();
        int i=1;
        {
            int  b= 20;
        }
        int j = 2;
        System.out.println(i);
    }
    ```

    

- 操作数栈（Operand Stack）

  - 每一个独立的栈帧中除了包含局部变量表外，还包含一个后进先出的操作数栈。
  - 操作数栈，在方法执行的过程中，根据字节码指令，往栈中写入或提取数据，即入栈/出栈。
  - 操作数栈，主要用于保存计算过程的中间结果，同时作为操作过程中变量的临时存储空间。
  - 操作数栈是jvm执行引擎的一个工作区，当一个方法开始执行时，一个新的栈帧也会随之创建，操作数栈也会被创建，只不过是空的。
  - 每一个操作数栈都会拥有一个明确的栈深度用于存储数值，其所需的最大深度在编译时就已经确定了，位方法的code属性中max_stack值。
  - 栈中的任意一个元素都可以是任意的java类型。
  - 操作数栈 **并非采用访问索引的方式来进行数据访问的**，而是只能通过编撰的入栈和出栈操作来完成一次数据访问。
  - 如果被调用的方法带有返回值，其返回值会被压入当前栈帧的操作数栈中，并更新寄存器下一条需要执行的指令。

- 动态链接（Dynamic Linking）指向运行时常量池的方法引用

  - 每一个栈帧内部都包含一个指向运行时常量池中该栈所属帧方法的引用，包含这个引用的目的就是为了支持当前方法的代码能够实现动态连接。
  - java源文件被编译成字节码文件时，所有变量和方法引用都作为符号引用保存在class文件的常量池里。比如,描述一个方法调用了另外的其他方法时，就是通过常量池中指向方法的符号引用来表示的，动态链接的作用就是为了将这些符号引用转换为调用方法的直接引用。

  **方法调用**

  jvm中，将符号引用转换为调用方法的直接引用与方法的绑定机制有关。

  - 动态链接

    如果被调用的方法在编译器无法被确定下来，即只能够在程序运行时将符号引用转换为直接引用，具有被动性。

  - 静态链接

    当一个字节码指令被装在进jvm内部时，如果被调用的目标方法在编译期可知(在编译时就可以确定调用的到底是哪个类哪个方法),且在运行期保持不变，这种情况下将调用方法的符号引用转换为直接引用

  分别对应晚期绑定和早期绑定。

  **非虚方法**

  - 在编译时就能确定方法的调用版本，且这个版本在运行时是不变的。

    - 构造器
    - final修饰的方法
    - 静态方法
    - private方法

    这些方法都没有多态的特性

- 方法返回地址（Return Address）

  - 存放调用该方法的pc寄存器的值(eg  a=x();当执行到这一条语句时，x()栈帧的方法返回地址存的是待用x()方法是的pc寄存器的值，方便边执行完x()方法后继续执行)
  - 一个方法的结束有两种，一种是正常退出，一种是非正常退出。正常退出是会把调用者pc寄存器的值存到调用的方法的方法返回地址。非正常退出根据异常表来确定。

- 一些附加信息

  - 对程序调试提供支持的信息，不一定有。

#### 本地方法栈

- Java虚拟机栈用于管理Java方法的调用，而本地方法栈用于管理本地方法栈的调用
- 本地方法栈是线程私有的
- 允许被实现成固定后者是可动态扩展的内存大小
  - 如果线程请求分配的栈容量超过本地方法栈允许的最大容量，java虚拟机会抛出一个StackOverFlow异常
  - 如果本地方法栈可以动态扩展，且在尝试扩展时无法申请到足够的内存，那么会跑一个OutOfMemoryError异常
- 本地方法是由C语言实现的
- 他的具体做法是在本的方法栈登记要调用的本地方法，然后再执行引擎中加载本地方法库。



### 堆

**堆的核心概念**

- 一个jvm实例只存在一个堆内存，堆也是java内存管理的核心区域。一个进程对应一个jvm实例。
- java堆区在jvm启动时就被创建了，其空间也就确定了。是jvm管理的最大的一块内存空间，堆内存的大小是可以调节的。
  - -Xms：最小堆内存
  - -Xmx：最大堆内存
- java虚拟机规范规定，堆可以处于物理上不连续的内存空间中，但在逻辑上他是连续的。内存映射表
- 所有线程共享java堆，但是在堆里还会为线程专门划分每个线程都私有的缓冲区(Thread Local Allocation Buffer
- 几乎所有的对象实例和数组都因该在运行时分配到堆上
- 对象和数组可能永远不会存在栈上，因为栈帧中保存引用，这个引用指向对象或者数组在堆中的位置。
- 方法结束后，堆中的对象不会被立马移除，仅仅在垃圾收集的时候才会被移除。
- 堆是GC(Garbage Collection)执行垃圾回收的重点区域。

**堆的内存细分**

​	**现代垃圾收集器大部分都是基于分代收集理论设计，堆空间细分为：**

- jdk1.7及之前
  - 新生代
  - 老年代
  - 永久代
- jdk1.8及之后
  - 新生代
    - 幸存者0区
    - 幸存者1区
    - 伊甸园区
  - 老年代
  - 元空间

**堆空间大小的设置**

- java堆区用于存储java对象实例，那么堆的大小在jvm启动时就已经设置好了，可以通过 -Xms -Xmx 进行设置

  - -Xms 用于设置堆区的起始内存  等价  -XX:InitialHeapSize
  - -Xmx 用于设置堆区的最大内存  等价  -XX:MaxHeapSize

- 一旦堆区的内存大小超过 -Xmx 所指定的最大内存，将会抛出 OutOfMemory异常

- 通常会将 -Xms 与 -Xmx 设置成两个参数相同的值，**目的是为了能够在java垃圾回收机制清理完堆区后不需要重新分割计算堆区大小，从而提高性能**，当设置了最大堆内存后，如果其实内存不够用，将扩展堆内存，而不需要这么多内存的时候，扩展的内存又会被回收。

- 默认情况下，初始内存大小： 电脑物理内存/64

  ​						最大内存大小：电脑物理内存/4

**新生代与老年代**

- 存储在jvm中的java对象可以划分为两类：
  - 以来是生命比较短的顺势对象，这类对象的创建和消亡都非常迅速
  - 另一类对象的生命周期非常长，在某些极端的情况下可与jvm生命周期保持一致
- java堆区进一步细分的话，可以划分为年轻代和老年代
- 其中年轻代有可以划分为Eden空间,Survivor0空间,Survivor1空间
- 默认情况下，新生代和老年代在堆区占比
  - 默认-XX:NewRatio=2  即新生代代表1，老年代代表2     2/1
  - 可以修改-XX:NewRatio=4    新生代为1 ，老年代为4
- 在HotSpot中，Eden空间和另外两个Survivor空间缺省所占比例为8：1：1
- 开发人员可以通过-XX:SurvivorRatio来调整这个空间比例 。    虽然HotSpot虚拟机中Eden空间和另外两个Survivor空间缺省所占比例为8：1：1，但实际上并不是这样，需要手动调整-XX:SurvivorRatio=8

**对象分配过程**

对象首先会在伊甸园区创建，直到伊甸园区满了，出发YoｕngGC/MinorGC，还有被引用的对象会被复制到幸存者0区，同时伊甸园区对象所占内存全部释放，放入幸存者0区的对象年龄计数器+1。接着继续在伊甸园区创建对象，当它再次放满时，出发YoｕngGC/MinorGC，把伊甸园区和幸存者0区还有被引用的对象复制到幸存者1区，同时回收伊甸园区和幸存者0区内存空间。如此直到幸存者区有对象的年龄计数器到了**15**，这些对象会被放到老年区。

- 针对幸存者s0，s1区的总结：复制之后有交换，谁空谁是to。
- 关于垃圾回收：频繁在新生去收集，很少在养老区收集，几乎不在永久区/元空间。
- YuongGC/MinorGC是针对伊甸园区的ＧＣ，而不是幸存者区,幸存者区只是被动进行GC。
- 特殊情况
  - 对象申请的内存非常大,超出了伊甸园区,则这个对象将直接放到老年区.老年区如果放放不下,则会执行FGC,执行FGC后,若能放下该对象则放在老年区,若放不下则OOM.
  - 在YGC时,如果从伊甸园区来的对象Survivor放不下,则将它直接晋升到老年代.

**MinorGC MajorGC  FullGC**

jvm在进行GC时,并非每次都对上面三个内存区域一起回收的,大部分回收都是指新生代。

正对HotSpot的实现，他里边的GC按照回收区域又分为两大种类型：一种是部分收集(Partial GC)，一种是整堆收集(Full GC)

- 部分收集：不是完整收集整个Java堆的垃圾收集。其中分为：

  - 新生代收集(MinorGC/YoungGC): 只是新生代的垃圾收集。
  - 老年代收集(Major GC/ Old GC): 只是老年代的垃圾收集。

  目前，只有CMS GC会有单独收集老年代的行为。

  **职意，很多时候MajorGC会和FullGC混淆使用，具体要分辨是老年代回收还是整堆回收**

  - 混合收集(Mixed GC)：手机整个新生代及两部分老年代的垃圾收集
    - 目前只有G1 GC会有这种行为

- 整堆收集(Full GC):收集整个Java堆和方法区的垃圾收集。

**年轻代GC触发机制：**

- 当年轻代空间不足时，就会触发MinorGC，这里的年轻代指的是Eden代满，Survivor满不会引发GC
- 因为Java对象大多都具备朝生夕灭的特性，所以MinorGC非常频繁，一般回收速度也比较快
- MinorGC会引发STW(Stop the World)，它会暂停其他用户线程，等垃圾回收结束，用户线程才能恢复运行。

**老年代GC触发机制：**

- 指发生在老年代的GC，对象从老年代消失时，我们说MinorGC或FullGC发生了
- 出现了MajorGC经常会伴随至少一次MinorGC
  - 当老年代空间不足时，会尝试触发MinorGC，如果空间还不足，则出发MajorGC
- MajorGC速度一般会比MinorGC慢10倍以上，STW时间更长。
- 如果MajorGC后，内存空间还是不足，就会直接报OOM

**FullGC触发机制：**

1. 调用System.gc(),系统建议执行FullGC，但不是必然执行
2. 老年代空间不足
3. 方法区空间不足
4. 通过MinorGC后进入老年代的对象大小大于老年代可用内存
5. 在Eden，Survivor0区向Survivor1区复制时，对象大小大于To 空间大小，则把该对象转到老年代，并且老年代内存大小小于该对象大小

**分代思想**

堆空间不分代完全可以，只是性能会大大降低。类比垃圾回收分类，如果所有垃圾都在一起，那么回收的时候就很麻烦，比如只要钢铁，就得从所有垃圾里找钢铁。加上java对象生命周期普遍较短，对生命周期较短的对象清理频率比较高，分代就很有必要。

**内存分配策略**

- 优先分配到Eden
- 大对象直接分配到老年代
- 长期存活的对象分配到老年代
- 动态对象年龄判断
  - 如果Survivor区中相同年龄的所有对象大小总和大于Survivor空间的一半，年龄大于或等于改年龄的对象可以直接进入老年代，无需等待MaxTenuringThreshold中要求的年龄
- 空间分配担保
  - -XX:HandlePromotionFailure

**什么是TlAB**

- 从内存模型而不是垃圾回收角度，对Eden区域进行继续划分，JVM为每个线程分配了一个私有缓存区域，它包含在Eden空间内。
- 多线程同时分配内存时，使用TLAB可以避免一系列的非线程安全问题，同时还能提升内存分配吞吐量，这种分配策略也叫快速分配策略。
- 尽管不是所有对象实例都能够在TLAB中成功分配内存，**但JVM确实将TLAB作为内存分配首选**
- 在程序中，可以通过选项-XX:UseTLAB设置是否开启TLAB空间
- 默认情况TLAB只占整个Eden的1%，可以通过-XX:TLABWasteTargetPercent修改
- 一旦对象在TLAB空间分配内存失败，jvm就会尝试通过加锁机制确保数据操作的原子性，从而直接在Eden空间分配内存

**堆空间常用参数**

- -XX:PrintFlagInitial     查看各个参数初始值
- -XX:PrintFlagFinal       查看各个参数最终值
- -Xms                             设置堆内存初始大小
- -Xmx                             设置堆内存最大大小
- -Xmn                             设置新生代大小
- -XX:NewRatio               设置老年代内存大小与新生代之比
- -XX:SurvivorRatio         设置伊甸园区内存大小与s0/s1空间的比例
- -XX:MaxTenuringThreshold     设置新生代垃圾阙值
- -XX:PrintGCDetails       打印GC日志

**堆是分配对象存储的唯一选择吗**

随着JIT编译器的发展与逃逸分析技术逐渐成熟，**栈上分配、标量替换优化技术**将会导致一些卫冕的表换，所有的对象都分配到堆上也渐渐变得不那么绝对了。

在Java虚拟机中，对象是在Java堆中分配内存的，这是一个普遍的常识，但是有种特殊情况，**就是如果经过逃逸分析(Escape Analysis)后发现，一个对象并没有逃逸出方法的话，那么就可能被优化成栈上分配。**这样就无需在堆上分配内存，也不用进行垃圾回收了。

- 如何将堆上的对象分配到栈，需要使用逃逸分析手段
- 这是一种可以有效减少java程序中同步负载和内存堆分配压力的跨函数全局数据流分析算法
- 通过逃逸分析，Java  HotSpot编译器能够分析出一个新的对象的引用适用范围从而决定是否要把这个对象分配到堆上
- 逃逸分析的基本行为就是分析对象的动态作用域
  - 当一个对象在方法中被定义后，对象只在方法内部使用，则认为没有发生逃逸
  - 当一个对象在方法中被定义后，他被外部方法所引用，则认为发生逃逸。例如作为调用参数传递到其他方法中
- jdk1.8后，自动开启逃逸分析。  `-XX:+DoEscapeAnalysis`
- 标量替换优化技术  默认打开   `-XX:+EliminateAllocations`

```java
// 判断是否发生逃逸，只看new对象实体是否有可能在方法外被
public class EscapeAnalysis{
    private EscapeAnalysis obj;
    
    /*
    	发生逃逸，因为最后一定会返回一个EscapeANalysis对象	
    */
    public EscapeAnalysis getInstance(){
        return obj==null?new EscapeAnalysis():obj;
    }
    
    /*
    	发生逃逸，给成员属性赋值	
    */
    public void setObj(){
        this.obj=new EscapeAnalysis();
    }
    
    /*
     	未发生逃逸	
    */
    public void useEscapeAnalysis(){
        EscapeAnalysis e = new EscapeAnalysis();
    }
    
    /*
     	引用了成员变量的值 发生逃逸	
    */
    public void useEscapeAnalysis1(){
        EscapeAnalysis e = getInstance();
    }
}
```



### 方法区(元空间)

java虚拟机规范中明确说明：尽管所有的方法区在逻辑上是属于堆的一部分，但一些简单的实现可能不会选择去进行垃圾回收或者进行压缩。但对于HotSpot虚拟机而言，方法区还有一个别名叫Non-heap(非堆)，目的就是要和堆分开。

所以，方法区看作是一块独立于java堆的内存空间。元空间使用的是物理内存，而非jvm内存

- 方法区和Java堆一样，是各个线程共享的内存区域
- 方法区在jvm启动时被创建，且它的实际物理内存和堆一样可以是不连续的(逻辑上连续)
- 方法区的大小可以固定大小，也可以自动扩展
- 方法区的大小决定了系统可以保存多少各类，如果系统定义了太多的类，导致方法区溢出，同样会有OOM
- 关闭jvm，方法区释放。

**设置方法区内存大小**

- 元数据区的大小可以使用参数-XX:MetaspaceSize和-XX:MaxMetaspaceSize来设置
- 默认依赖于平台。windows下，-XX:MetaspaceSize是21M，-XX:MaxMetaspaceSize是-1，即没有限制。
- 与永久代情况不同，如果不指定大小，默认情况下，虚拟机会耗尽所有系统可用的内存，如果元数据区发生溢出，虚拟机一样会抛出OOM:Metaspace
- -XX:MetaspaceSize：设置初始元空间大小。对于一个64未的服务器端jvm来说，其默认的-XX:MetaspaceSize 为21m。这就是初始的高水平线，一旦触及这个水平线，FullGC将会被触发并写在没有用的类(即这些类对应的类加载器不再激活)，然后这个高水平线会被重置。新的高水平线值取决于GC后释放了多少元空间。如果释放的空间不足，那么水平线将会适当提高。如果释放空间过多，这适当降低该值。
- 如果初始化的高水平线设置过低，上述高水平线调整情况会发生多次，为了避免多次FGC，请将-XX:MetaspaceSize设置为一个较高的值。

**方法区的内部结构**

它用于存储 **类型信息、常量、静态变量、即时编译器编译后的代码、方法信息、域信息**

`javap -v -p xxx.class` -p 可以把一些权限较小的属性或者是方法加载出来

- 类型信息

  ```
  public class com.flyingdigital.MethodInnerStructTest extends java.lang.Object implements java.lang.Comparable<java.lang.String>, java.io.Serializable
    minor version: 0
    major version: 52
    flags: ACC_PUBLIC, ACC_SUPER
  ```

  - 每个加载的类型(类class，接口interface、枚举enum、注解annotation)，jvm必须在方法区中存储以下信息
    1. 这个类型的完整有效的名称(全名=包名.类名)
    2. 这个类型的直接父类的完整有效名(对于interface或是java.lang.Object)
    3. 这个类型的修饰符(public abstract  final的某个子集)
    4. 这个类型直接接口的一个有序列表

- 域信息

  ```java
    private java.lang.String str;
      descriptor: Ljava/lang/String;
      flags: ACC_PRIVATE
  
    private int i;
      descriptor: I
      flags: ACC_PRIVATE
  
  ```

  - jvm必须在方法区中保存类型的所有域的相关信息以及域的声明顺序
  - 域信息包括：域名称，域类型，域修饰符

- 方法信息

  ```java
   public void test();
      descriptor: ()V
      flags: ACC_PUBLIC
      Code:
        stack=2, locals=1, args_size=1
           0: getstatic     #2                  // Field java/lang/System.out:Ljava/io/PrintStream;
           3: bipush        123
           5: invokevirtual #3                  // Method java/io/PrintStream.println:(I)V
           8: return
        LineNumberTable:
          line 10: 0
          line 11: 8
        LocalVariableTable:
          Start  Length  Slot  Name   Signature
              0       9     0  this   Lcom/flyingdigital/MethodInnerStructTest;
  
  ```

  - 方法名称
  - 方法返回类型
  - 方法参数的数量和类型
  - 方法修饰符
  - 方法字节码，操作数栈，局部变量表大小
  - 异常表
    - 每个异常处理的开始位置、结束位置、代码处理在程序计数器中的偏移地址、被捕获的异常类的常量池索引

**运行时常量池vs常量池 **

- 常量池

  一个有效的字节码文件中除了包含类的版本信息、字段、方法及接口等描述信息外，还包含一项信息就是常量池表，包括各种字面量和类型、域、方法的符号引用。（数量值，字符串值，类引用，字段引用，方法引用）

  **常量池可以看作是一张表，虚拟机指令根据这张表找到要执行的类名，方法名，参数类型，字面量等等**

- 运行时常量池

  - 是方法区的一部分

  - **常量池表是class文件的一部分，用于存放编译期生成的各种字面量和符号引用，这部分内容加载类加载后存放到方法区的运行时常量池中。**

  - 运行时常量池，在加载类和接口到虚拟机后，就会创建对应的运行时常量池。

  - jvm为每个已加载的类型都维护一个常量池。池中的数据项象数组一样通过索引访问。

  - 常量池中包含多种不同的常量，包括编译器确定的数值字面量，也包括运行起解析后才能获得的方法或者字段引用。此时不再是常量池中的符号引用而是真正的物理地址。

    - 运行时常量池相对于class文件另一重要特征是 **具备动态性**	

      - eg： 加载一些没有在常量池中出现的方法 String.intern()


**方法区的演进细节**(针对 HotSpot虚拟机)

- 1.6及之前  有永久代，静态变量放到永久代上
- 1.7   有永久代   但已经逐步去除永久代，字符串常量池和静态变量存放在堆中
- 1.8及之后   无永久代  类型信息、方法信息、域信息、常量池等存放在元空间，静态变量和字符串常量池存放在堆中







### 本地方法接口(native method interface)

简单来讲，**一个Native Method就是一个Java调用非Java代 码的接口**。一个Native Method的实现由非Java语言实现，比如C。





### 对象实例化

#### 创建对象的方法

- new   包括静态实例化工厂实例化
-  反射  Class的newInstance()和 Constructor的newInstance(Xxx) 
- clone
- 反序列化
- 第三方Objenesis

#### 创建对象的步骤

- 判断类是否加载到内存里  加载，链接，初始化
- 为对象分配内存 
  - 空间规整 ： 指针碰撞(即把指针往后移动一个对象长度
  - 空间不规整： 找一块可用空间分配内存
- 并发安全问题
- 对象默认初始化   零值初始化
- 设置对象头信息
- 显式初始化(代码块 显式赋值  构造器方法)

#### 对象内存布局

**对象头**

- 元数据区
  - 哈希值
  - GC分代年龄
  - 锁状态标志
  - 线程持有的锁
  - 偏向线程ID
  - 偏向时间戳
  - GC标记
- 类型指针
  - 指向方法区这个对象的类型
- 如果是数组还应有长度

**实例数据**

- 他是对象真正存储的有效信息，包括程序代码中定义的各种实例字段  包括父类的实例字段

**对齐填充**

- 不是必须的 仅有占位符作用





#### StringTable

**String的基本特性**

- String： 字符串，使用一对""引起来表示
- String声明为final的  不可被继承
- String实现了Serializable接口：表示字符串支持序列化，实现了Comparable接口：表示字符串可以比较大小
- String在jdk1.8之前使用char数组存储数据，1.8之后使用byte

```java
package com.flyingdigital;

public class StringTest {

    static String string = "good";
    static char[] chars = {'t','e','s'};

    public static void change(String str,char s[]){
        System.out.println(str);
        str = "heihei";
        System.out.println(string);
        System.out.println(str);
        s[0]= 'm';
    }

    public static void main(String[] args) {
        change(string,chars);
        System.out.println(string);
        System.out.println(chars);
    }
}
```

- **字符串常量池中是不会存储相同内容的字符串的**
- String的String Pool是一个固定大小的HashTable，默认长度为1009(jdk1.6),如果让在StringPool的String非常多，就会在场Hash冲突严重，从而导致链表会很长，而链表长了后会直接造成影响就是String.intern()性能大幅下降
- -XX:StringTableSize可以调整StringTable大小
- jdk1.6中，StringTable的大小固定为1009
- jdk1.7中，StringTable长度为60013
- jdk1.8中  StringTable可以设置的最小值为1009

**字符串拼接**

- 常量于常量的拼接结果放在常量池

- 常量池不会存放相同内容

- 只要有一个是变量，结果就是new一个新的String在堆里

  具体细节是有一个String变量进行拼接时，底层new了一个StringBuilder ，然后append ，toString()

  （两个带final的变量相加不会调用StringBuilder）

  ```java
  final String a = "s";
  final String b = "b";
  String c = a + b;   // 这是不会调用String
  ```

  

- 如果拼接的结果调用intern()方法，则会把常量池中还没有的字符串对象放入常量池中，并返回此对象地址。

**关于intern()**

```java
/*
 * 
1.  s1创了两个对象 一个是字符串常量 “1” 一个是堆里的new String("1")
2. s1.intern()之前  "1"就已经存在于常量池中了
3. s3虽然底层调用了StringBuilder  但是实际上并没有在字符串常量池里创建"11"， 只在堆里创建了 new String("11")  
 */
String s1 = new String("1");
s1.intern();
String s2 = "1";
String s3 = new String("1") + new String("1");
```

```java
/*
 * 
1. 毫无疑问  s1的对象在堆里创建  且常量池没有"11"
2. jdk7后  会在常量池里创建一个对象  这个对象并不是"11"  而是指向s1的引用  为了省空间  骚操作
3. 这时s2=“11” 去常量池找”11“  而“11”又指向s1  故二者相等
*/

String s1 = new String("1") + new String("1");
s1.intern()
String s2 = "11";
sout(s1==s2);//true
```



### 垃圾回收概述

**什么是垃圾**

- 垃圾指的是运行程序中没有任何指针指向的对象，这些对象就是要被回收的垃圾
- 如果不及时回收这些垃圾，那么这些垃圾将占据内存直到程序结束，由于他们所占有的内存空间不被释放，其他对象也无法使用，可能导致内存溢出

**为什么需要GC**

- 内存迟早都会被消耗完，因为不断地创建对象，分配内存，又不清除。
- 除了释放没用的对象，垃圾回收也可以清除内存里的记录碎片。随碎片将整理放置到堆的一段，以便jvm将整理出的内存分配给新的对象。
- 随着应用程序所应付的业务越来越庞大复杂，没有GC程序就无法正常运行(内存消耗完)，而经常GC又会有STW，用户线程会被停止，所以才有对GC的优化。

频繁清理年轻代，较少清理老年代，基本不动方法区

#### 垃圾标记算法(判断对象是否存活)

如果一个对象没有被存活的对象继续引用，这个对象就已经死亡。

**引用计数算法**

引用计数算法：对每一个对象都保存一个整形的引用计数器属性(初始为0)，用于记录对象被引用情况。(引用一次+1，引用失效-1)

优点：实现简单，垃圾便于识别。判定效率搞，回收无延迟性。、

缺点：

	1. 增加一个属性，增加了存储空间
 	2. 每次加减消耗时间
 	3. 致命问题：  没法解决循环引用问题。java不采用此种算法。

循环引用：

​	P->A->B->C->A

​	p指向A对象，A对象里的属性指向了B对象，B对象的属性又指向了A对象。当P引用失效时，A的引用计数器虽然减一，但C仍有A的引用，这样导致ABC三个都无法被标记。(ABC三个对象的引用计数器都不为零)

**可达性分析(跟搜索算法、追踪性垃圾收集)**

基本思路：

- 可达性分析算法是根据根对象(GC roots)为起始点，**从上至下的方式搜索根对象集合所连接的目标对象是否可达**
- 使用可达性分析算法后，内存中的存活对象都会被根对象集合直接或间接连接着，搜索所走过的路径成为引用链
- 如果目标对象没有任何引用链相连，则是不可达的，意味着对象已经死亡，可以标记为垃圾对象
- 可达性分析算法中，只有能够被根对象集合或者间接连接的对象才是存活对象

**GC Roots包括以下几类元素**

- 虚拟机栈中引用的对象(局部变量表)
- 本地方法栈中引用的对象
- 堆中的静态变量引用的对象
- 常量池中引用的对象(字符串常量池)
- 所有被同步锁synchronized持有的对象
- Java虚拟机内部的引用  比如常驻各种异常

**finalization机制**

- Java语言提供了对象终止机制来允许开发人员提供对象销毁之前的自定义处理逻辑
- 当垃圾回收器发现没有引用指向一个对象，即：垃圾回收此对象之前，总会先调用这个对象的finalize()方法
- finalize()方法定义在object类，允许被子类重写，用于在对象回收时进行资源释放。通常在这个方法中进行一些资源释放和清理的工作，比如关闭文件、套接字、数据库连接等等
- 永远不要主动调用finalize()方法，应该交给垃圾回收机制调用
  - finalize()可能会导致对象复活
  - finalize()方法执行的时间是没有保障的，他完全由GC线程决定，极端情况下，若不发生GC，finalize()方法也不会被调用。
  - 糟糕的finalize()方法会影响GC性能，比如死循环
- 从功能上来说，finalize()与C++中的析构函数比较相似，但是Java采用的是基于垃圾回收的自动内存管理机制，所以finalize()本质上与析构函数不同。
- 由于finalize()方法存在，虚拟机中的对象可能有三种状态。
- 如果所有根节点都无法访问到某个对象，说明对象就已经不再被引用了。一般来说，此对象需要被回收。但事实上，这时候他们处于一种死缓状态(由于finalization机制存在)。一个无法触及的对象有可能在某一个条件下复活自己
  - 可触及的：从根节点开始可以到达这个对象
  - 可复活的：对象的所有引用都被释放，但是对象可能在finalize()中复活
  - 不可触及的：对象的finalize()被调用，并没有复活，那么就会进入不可触及状态。不可触及的状态对象不可能复活.**finalize()方法只会调一次**
- 具体过程：判断一个对象是否可以回收，至少要经历两次标记过程
  1. 如果对象没有到GCRoots上的引用链，则进行第一次标记。
  2. 进行筛选，判断对象是否有必要执行finalize()方法
     1. 如果对象没有重写finalize()方法，或者finalize()方法已经被虚拟机调用过一次，则虚拟机时为没有必要执行，对象被判定为不可触及的。
     2. 如果对象重写了finalize()方法，且还没有被执行过，那么这个对象会被插入到F-Queue队列中，有一个虚拟机自动创建的、低优先级的**Finalizer线程(这个线程的优先级非常低)**触发其finalize()方法执行
     3. finalize()**方法是对象逃脱死亡的最后机会**，稍后GC会对F-Queue队列中的对象进行第二次标记，如果对象finalize()方法中与引用链上的任意对象建立了联系，那么在第二次标记时，对象会被移出即将回收之列。之后对象再次出现没有引用存在的情况，finalize()方法不会被调用，对象会直接变为不可触及的状态。即 **finalize()方法只会被调用一次**





#### 垃圾清除阶段

**标记-清除算法(Mark-Sweep)**

执行过程：当堆中的有效内存空间被耗尽时，就会停止整个程序(Stop the World)，然后进行两项工作，分别是标记，清除。

- 标记：Collector从引用根节点开始遍历，标记所有被引用的对象。一般实在对象都中记录为可达对象。
- 清除：Collector对堆内存从头到尾进行遍历，对象头中没有被标记的对象将被清除。(对象不可达)

缺点：

- 效率不算高
- 在进行GC时需要停掉用户线程，用户体验差。标记需要递归遍历一次，清除又要遍历一次！
- 这种方式清理出来的内存并不是连续的，产生内存碎片，因此需要额外维护一个空闲列表来记录空闲内存。

关于清除：

- 这里的清楚并不是真的置空，而是把需要清除的对象地址放到空闲列表中。实质上是一个覆盖，下一个对象来的时候直接把源对象给覆盖掉。

**复制算法**

把活着的内存空间分成两份，每次只用其中的一块，在垃圾回收时将正在使用的内存中活着的存活对象复制到未被使用的内存块中，之后清除未被使用的内存块，交换内存角色，最后完成垃圾回收。这个算法应用到了新生代里的幸存者区。

优点：

- 没有标记和清除的过程，实现简单，运行高效。不需要再维护内存空闲列表。
- 复制具有连续性，不会有内存碎片。把活着的对象从A复制到B，B从头开始接收被复制的对象。

缺点：

- 他需要两倍的内存空间。
- 对于G1这种分拆成为大量region的GC，复制而不是移动，意味着GC需要维护region之间对象引用关系，内存占用和时间开销也不小。栈中的指针指向A，GC后原本A被复制到了B，栈中的指针相应的也应该指向B。

特别的：

- 如果系统中的垃圾对象特别多，复制算法复制的对象不应该特别多，或者非常低才行。比如有100个对象，GC后还剩90个，这种场景下复制算法是不合适的，因为垃圾对象太少了，而复制和维护region是需要时间的。但若100个对象GC后只有几个，这种情况时非常合适复制算法的，比如新生代。

  **标记压缩算法**(老年代)

第一阶段和标记-清除算法一样，从根节点开始标记所有被引用对象。

第二阶段将所有对象压缩袋内存的一端，按顺序排放，之后清理所有边界外空间。

缺点：

- 效率上低于标记清除算法
- 移动对象的同时，如果对象被其它对象引用，同样需要修改引用地址

优点：

- 解决了标记清除算法内存碎片的问题
- 解决复制算法内存减半问题
- jvm只需要持有一个内存的起始地址

**分代收集算法**

具体问题具体分析，根据新生代，老年代特性采用不同的垃圾清除算法。

**增量收集算法**

基本思想：

- 如果一次性将所有的垃圾进行处理，需要造成系统长时间的停顿，那么就可以让垃圾收集线程与用户线程并发执行。每次，垃圾收集线程只清理一部分空间，接着切换到应用线程。以此往复，直到垃圾收集完成。
- 总的来说，增量收集算法的基础仍是创痛的标记清除算法和复制算法。增量收集算法通过对县城冲突的妥善处理，允许垃圾收集线程以分阶段方式完成标记，清理或复制工作。



**分区算法**

一般来说，相同条件下，堆空间越大，一次GC所需要的时间就越长。将一个大的内存分割成许多小块，根据目标的停顿时间，每次合理的回收若干小块，而不是整个区间，从而减少一次GC停顿。

粉黛算法将按照对象的生命周期长短划分成两个部分，分区算法将整个堆空间划分成连续的不同的小区间region。

每个小区间独立使用，独立回收。这种算法的好处是可以控制一次回收多少个小区间。



#### 垃圾回收相关概念

**System.gc()的理解**

- 默认情况下，通过System.gc()或者Runtime.getRuntime.gc()的调用，会显示触发fullgc,同时对新生代，老年代进行回收，尝试释放被丢弃对象占用的内存。
- 然而System.gc()调用附带一个免责声明，无法保证堆垃圾收集器的调用，即没法保证调用System.gc()后立马执行gc！
- jmv实现者可以通过System.gc()的调用来决定jvm的gc行为。而一般情况下，垃圾回收应该是自动进行的，无需手动触发。在一些特殊情况下，如果我们正在编写一个性能基准，我们可以在运行之间调用System.gc()

**内存溢出与内存泄漏**

**内存溢出(OOM)**：内存空间不够了，在进行GC后内存空间还是不够，就开始报OOM

导致内存溢出的原因有两种：

- 内存空间分配的本来就不够。比如80M的内存空间，要存一个100M的对象
- 存在很多无法直接被垃圾回收的对象





**内存泄露**

只有对象不会再被用到了，但是GC又回收不了，才叫内存泄漏。

举例：当不想引用一些对象时，应该断开连接他的指针，但是忘了断开，想清除又有引用，就清不掉，发生内存泄漏



**Stop the World**

- 指的是GC的事件发生过程中，会产生应用程序的停顿。停顿生产时整个应用程序线程都会被暂停，没有任何响应，这个停顿成为STW
  - 可达性分析算法中枚举根节点会导致所有Java执行线程停顿
    - 分析工作必须在一个能确保一致性的快照中进行，即不能在进行可达性分析时出现新的对象。
    - 一致性至整个分析期间执行系统好像冻结在某个时间点上
    - 如果出现分析过程中，对象引用关系还在不断变化，则无法保证分析结果准确
- STW无法避免 ，可以减少发生频率





**程序的并发与并行**

**并发**

- 操作系统中，指一个时间段中程序在同一个处理器上交替执行，每一个时刻只有一个程序在运行

- 并不是真正意义上的同时进行，只是cpu把一个时间段划分成了几个时间片段，然后在这几个时间区间之间来回切换，由于cpu处理的速度非常快，只要时间间隔处理恰当，就可以让用户感觉是多个程序同时进行。

**并行**

- 当系统有一个以上cpu时，当一个cpu执行一个进程时，另一个cpu可以执行另一个进程，两个进程互补抢占cpu资源，可以同时进行。
- 决定cpu并行并不是cpu的数量而是cpu核心数量，比如一个cpu有多核，同样可以并行

**并发vs并行**

并发，指的是多个事情，在同一时间段内同时发生了。(一个处理器)

并行，指的是多个事情，在同一时刻同时发生了。(多个处理器)

**垃圾回收的并发与并行**

**并行**

- 指 **多条垃圾收集线程并行工作**，此时用户线程处于等待状态(STW)
  - eg: ParNew,Parallel Scavenge, Parallel Old

**串行**

- 相较于并行，只有一个垃圾线程执行，用户线程会被停止
- 如果内存不够，则程序暂停，启动jvm垃圾回收器进行垃圾回收。回收完再启动程序线程

**并发**

- 指同一时间段内 **用户线程与垃圾线程同时执行**(但不一定是并行的，可能会交替执行)，垃圾回收线程在执行是不会停顿用户将程序的执行
  - 用户程序继续执行，而垃圾收集程序线程运行与另一个cpu上
    - cms g1



**安全点与安全区域**

**安全点(Safe Point)**

程序执行时并不是所有地方都能停下来GC，只有在特定的位置才能停顿下来GC，这些位置成为安全点。

SafePoint的选择很重要，如果太少可能导致GC等待时间太长(OOM)，如果太频繁可能影响运行时性能问题。大部分指令的执行时间都非常短，通常会根据 **是否具有让程序长时间执行的特征**为标准，比如选择一些执行时间较长的指令作为SafePoint，比如方法调用，循环跳转和异常跳转等等。

如何在发成GC时，检查所有线程都跑到了最近的安全点停顿下来？

- 抢先式中断(目前没有虚拟机采用了)
  - 首先中断所有线程。如果还有现成不在安全点，就恢复线程，让线程跑到安全点。
- 主动式中断
  - 设置一个中断标志，各个线程运行到safepoint时主动轮询这个标志，如果这个标值为真，则将自己进行中断挂起。

**安全区域(Safe Region)**

SafePoint保证程序执行时，在不太长的时间就会遇到可进入的GC的SafePoint。但是程序不执行时，比如Sleep后者Blocked状态，线程无法响应JVM中断请求，走到安全点挂起，JVM也不太可能等待线程被唤醒，这种情况就需要安全区域来解决

**安全区域指的是一段代码片段中，对象引用关系不会发生变化，这个区域任何位置开始GC都是安全的。**



#### 引用

- 强引用(StrongReference)：最传统的引用定义，只在程序代码之中普遍存在的引用复制，及类似 `Object obj = new Object()`这种引用关系。**只要强引用关系还在，垃圾回收器就永远不会回收被引用的对象**

- 软引用(SoftReference)：在系统要发生oom时，将会把这些对象列入回收范围中进行第二次回收。如果这次回收之后还是没有足够内存，则OOM。
- 弱引用(WeakReference): 被弱引用关联的对象只能存活到下一次垃圾收集之前，垃圾收集器工作时，无论内存是否足够，瑞引用关联对象都会被回收。
- 虚引用(PhantomReference)：为一个对象设置需用用关联的唯一目的是 **在这个对象被回收时收到一个系统通知**

**强引用**

java程序中，99%的引用都是强引用，也是默认的引用类型。

当Java语言使用new操作符创建一个对象，并将其复制给一个变量的时候，这个变量就成为指向该对象的一个强引用。

**强引用的对象是可触及的，垃圾收集器永远不会回收掉被引用的对象**。

**强引用也是造成Java内存泄漏的主要原因之一。**



**软引用**

软引用是来描述一些还有用，但非必须的对象。只被软引用关联着的对象，在系统将要发生OOM之前之前，就会把这些对象列进回收范围之中进行二次回收，如果这次回收后还是没有足够的内存，则报OOM。

软引用同通常用来实现内存敏感的缓存。比如：高速缓存就有用到软引用。如果还有空闲内存，就暂时保留缓存，当内存空间不足时就清理掉，这样就保证了使用缓存的同时，不会耗尽内存。



**弱引用**

弱引用也是来描述那些非必需对象，只被弱引用关联的对象只能存活到下一次垃圾回收发生为止。



**虚引用**

唯一作用是在这个对象被回收时收到一个系统通知



### 垃圾回收器

**垃圾回收器分类**

- 按线程数分(垃圾回收线程)，可以分为串行回收器和并行回收器
  - 串行垃圾回收器指的是在在同一时间段内只允许有一个cpu用于执行垃圾回收操作，此时工作线程被暂停，直至垃圾收集工作结束.(STW)
  - 并行收集可以用多个cpu同时进行垃圾回收，引起提高了应用吞吐量。但是也会有STW机制。
- 按工作模式分，可以分为并发式垃圾回收器和独占式垃圾回收器
  - 并发式垃圾回收器与应用程序交替工作，尽可能减少应用程序停顿时间
  - 独占式垃圾回收器一旦运行，用户线程就会被暂停，直到垃圾回收结束
- 按碎片处理分，可以分为压缩式垃圾回收器和非压缩式垃圾回收器
- 按工作的内存空间分，可以分为年轻代回收器和老年代回收器



**评价GC的性能指标**

吞吐量与暂停时间处于一种此消彼长状态！

- 吞吐量：用户代码运行之间占程序总运行时间的比例 
  - 吞吐量值 用户程序需运行时间/(用户程序需运行时间+GC时间)
- 暂停时间：执行垃圾回收时，程序的工作线程暂停的时间
- java内存占用： java堆区内存占用大小(大一些比较好)



**吞吐量vs暂停时间**

- 高吞吐量较好因为这会让应用程序的最终用户感觉只用应用线程在做生产性工作。直觉上，吞吐量越高，程序运行越快。
- 低延迟较好因为从最终用户角度来看，不管是GC还是其他原因导致用户线程被挂起是不好的。这取决于应用程序的类型，有时甚至200ms的停顿都可能打断用户体验。因此，具有地的较大停顿时间是非常重要的(暂停时间短)，特别是对于一个交互式应用程序。
- 高吞吐量和低暂停时间是此消彼长的！
  - 高吞吐量以为这减少内存回收频率，这会导致单次停顿时间较长
  - 而低暂停时间虽然每次暂停时间减少，但是总的吞吐量不够！

- 一个GC算法只能注重其中一个

  **现在垃圾回收标准是，在追求较高吞吐量的情况下，降低停顿时间，把停顿时间控制在一个看可控范围。**



**垃圾收集器**

- jdk1.3  出现Serial GC，他是第一款GC。ParNewGC是他的多线程版本。
- jdk1.4 出现 Parallel ScavengeGC 和 CMS
- jdk1.6  Parallel GC 成为HotSpot默认虚拟机
- jdk1.7 G1 可用
- jdk9 G1变成默认垃圾收集器  以替代CMS
- jdk11 引入 EpsilonGC 和 ZGC
- jdk14  删除CMS



串行回收器：Serial GC 、 Serial Old GC

并行收集器：ParNew GC、 Parallel GC、Parallel Old GC

并发收集器：CMS GC、 G1 GC



**7款经典GC与垃圾分代之间的关系**

- 新生代垃圾回收器
  - serial GC, Parallel Scavenge GC, ParNew GC
- 老年代垃圾回收器
  - serial old GC, Parallel Old GC, CMS GC
- 整堆收集
  - G1 GC

**搭配**

jdk8： 

- Serial GC/Serial Old
- ParNew GC/CMS GC
- Parallel  GC/ Parallel Old GC





查看当前程序运行了什么GC

```java
-XX:+PrintCommandLineFlags
```



**Serial回收器：串行回收**

- Serial收集器是最基本，历史最悠久的垃圾收集器。在jdk1.3之前是唯一选择。
- Serial收集器是HotSpot中Client模式下的默认新生代垃圾收集器。
- Serial收集器采用了复制算法、串行回收和STW机制回收内存
- 除了年轻代之外，Serial收集器还提供用于执行老年代垃圾收集器的Serial Old。Serial Old也采用了串行回收和STW机制，只不过内存回收算法是标记压缩算法。
  - SerialOld 是运行在Client模式下默认老年代垃圾收集器
  - Serial Old在Server模式下主要与Parallel搭配使用，还有作为CMS的备胎方案。
- 这个收集器是一个单线程的收集器，但他的单线程并不仅仅说他只会使用一个CPU或者一个线程去完成垃圾收集工作，更重要的是他在垃圾回收时，必须停掉其他工作线程，STW，直到它工作结束。



**ParNewGC：并行回收**

- 如果说SerialGC是年轻代单线程垃圾收集器，那么ParNewGC收集器是SerialGC的多线程版本。
- ParNew收集器除了并行回收内存外，两款垃圾收集器没有任何区别。它同样有STW机制
- 对于新生代，回收次数频繁使用并行方式高效。
- 对于老年代，回收次数少，使用创行方式节约资源。
- 可以通过`-XX:UseParNewGC`来确认是否使用ParNewGC
- 由于是并行的，可以通过`-XX:ParallelGCThreads`限制线程数量 
- 好处是由于ParNewGC是并发的，在新生代表现STW有缩短，仅此而已。



**Parallel ScavengeGC：吞吐量优先**

- Parallel ScavengeGC使用的是复制算法，并行回收和STW机制
- ParallelGC和ParNewGC性能差不多，为何多此一举？
  - ParallelGC目标时达到一个可控制吞吐量，吞吐量优先。
  - 自适应调节是ParNew和Parallel一个重要区别
- 在jdk1.6出现了ParallelOldGC，它的出现取代了原来回收老年代的SerialOldGC
  - 由于这类GC用于服务端，不许和用户打交道，故吞吐量优先较好
  - 多用于处理科学计算，批量处理，订单处理等等
- ParallelOldGC基于标记压缩算法，有STW机制，并行回收。

- `-XX:UseParallelGC`、`-XX:UseParallelOldGC`使用它们，他们两个相当于绑定的，设置一个，另一个自动激活

- `-XX:ParallelGCThreads`默认为cpu个数，如果大于cpu个数，来回切换cpu反而影响效率。
  - cpu<8   该值默认为8
  - cpu>8   该值为  3+(2*cpu_count/8)
- `-XX:MaxGCPauseMillis`设置最大停顿毫秒数  慎用
- `-XX:GCTimeRatio`   默认为99    即 GC时间占总时间1%
- `-XX:UseAdaptiveSizePolicy`  启动自适应调节策略
  - 在这种模式下，年轻代大小，伊甸园去和幸存者区比例，晋升老年区阙值都会自动调整，达到在堆大小吞吐量和停顿时间之间的平衡
  - 可以仅指定堆大小，最大吞吐量，停顿时间   让虚拟机自行调优



**CMS：低延迟**

- 在jdk1.5时期，HotSpot虚拟机推出了一款强交互应用中具有跨时代意义的垃圾收集器：CMS(Concurrent Mark Sweep)，这是HotSpot虚拟机第一款真正意义上的并发收集器，他第一次实现了让垃圾收集线程与用户线程同时工作！
- CMS收集器的关注点是尽可能缩短垃圾收集时用户线程停顿的时间。停顿时间越短就越适合与用户交互的程序
  - 目前很大一部分的Java应用集中在互联网站或者B/S系统的服务端上，这类应用尤其重视服务的响应速度，希望系统停顿时间最短，给用户良好体验。
- CMS采用了标记清除算法，同样也存在STW机制。
- CMS无法与ParallelGC搭配使用，原因是二者使用了不同的框架，不兼容

- **工作过程**：主要有四个阶段，初始标记、并发标记、重新标记、并发清除
  - 初始标记(Initial-Mark)阶段：这个阶段中，程序中所有工作线程都会因为STW被暂停，这个阶段主要任务是 **只标记与GCRoots直接能关联到的对象**，一旦标记完成后就会恢复之前暂停的所有应用线程。由于直接关联的对象比较少，所以这里 **速度非常快**
  - 并发标记(Concurrent-Mark)：**从GCRoots的直接关联对象开始遍历整个对象图的过程**，这个过程耗时表较长，但是不会停顿用户线程，可以与垃圾回收线程并发执行。
  - 重新标记阶段(Remark)：由于在并发标记过程中，程序的工作线程会和垃圾收集线程同时运行或者交叉运行，因此为了 **修正并发标记期间，用户线程继续运作而导致标记产生变动的那一部分对象的标记记录**，这个阶段的停顿时间通常会比初始标记药厂，但也远比并发标记时间短。
  - 并发清除(Concurrent-Sweep)：此阶段 **清除掉标记阶段半段已经死亡的对象，释放内存空间**。由于使用的是标记清楚算法，所以没有涉及整理内存碎片情况，这个阶段可以和用户线程并发执行，但同时碎片问题要维护空闲列表。



尽管CMS收集器采用的是并发回收，但是在其初始化标记和在此标记两个阶段仍有STW机制暂停工作线程，不过暂停时间不会太长。STW可以减少，但是不能做到完全没有。

由于最耗费时间的鬓发标记和并发清楚都不需要暂停工作，所以整体的回收是低停顿的。

另外，由于在垃圾收集阶段，用户线程没有中断，所以在CMS回收过程中，还应该确保应用程序用户线程有足够的内存。因此，CMS收集器不能等到老年代几乎被填满了再进行收集，而是当堆内存到达某一阈值时，就开始回收，以确保应用程序在CMS工作过程中依然有足够的空间支持应用程序运行。要是CMS运行期间预留的内存无法满足程序需要，就会出现`Concurrent Mode Failure`，这时只能启动后备方案，使用SerialOld来代替CMS进行老年代收集。

- 优点
  - 并发
  - 低延迟
- 缺点
  - 会产生内存碎片，导致并发清除后，用户线程可用空间不足，没法分配大对象，提前FGC
  - 对CPU组员非常敏感。在并发阶段，她虽然不会导致用户停顿，但会因为占用一部分线程而导致应用程序变慢，总吞吐量变低。
  - CMS无法清理浮动垃圾。可能出现Concurrent Mode Failure而导致FGC产生。并发标记阶段由于程序的工作线程和垃圾收集线程是同时运行或者交叉运行的，那么在并发标记阶段如果出现了新的垃圾对象，CMS将无法对这些垃圾对象进行标记，最终导致新的垃圾对象没有被及时回收，只能等到下一次GC来清除未被回收的内存。



**关于浮动垃圾的理解**：

重新标记主要有两种问题

	- 原本不可达的对象，变得可达了
	- 原本可达的对象，变得不可达了

这两种问题，cms只解决了第一种，这第一种就相当于我重新new了一个对象，原来本来应该清理的内存，现在不能清理了，这个清理了会出大问题，所以第一种情况是必须解决的

而第二种情况，如果想要解决，就必须重新遍历，耗费时间太大。其次，这种情况是可容忍的，就算不去清除，程序还是可以跑！  



**CMS可设置的参数**

- `-XX:UseConcMarkSweepGC`是否使用cms ，如果使用，那么默认新生代垃圾回收器为ParNewGC
- `-XX:CMSInitiatingOccupanyFraction`设置堆内存使用率的阈值，一旦达到该阈值，就开始回收
  - jdk1.6后默认为 92%
  - 如果内存增长缓慢，设置一个较高值，可以减低GC发生频率。如果内存增长快速，设置一个低一些的值，以免频繁触发老年代串行垃圾收集器。可以有效降低FGC执行次数。
- `-XX:UseCMSCompactAtFullCollection`是否在FullGC后整理内存碎片。
- `-XX:CMSFullGCsBeforeCompaction` 多少次FullGC后执行内存碎片整理   0代表每次都整理

- `-XX:ParallelCMSThreads` 设置CMS线程个数
  - CMS默认启动的垃圾收集线程个数  (ParallelGCThreads+3)/4  如果新生代有五个并行回收的线程，那么CMS默认启动两个垃圾收集线程







**G1回收器：区域分代化**

G1的目标是在延迟可控的情况下获得尽可能高的吞吐量，所以才担当起全功能收集器的重任。

- G1是一个并行的回收器，他把堆内存分割为很多不相关的区域(Region) (物理上不连续的)。使用不同的Region来表示Eden，幸存者0区，幸存者1区，老年代等。
- **G1有计划的避免在整个Java堆中进行全区域的垃圾收集。**G1跟踪各个Region里面的垃圾堆积的价值大小(回收所获得的空间大小以及回收所需时间的经验值)，在后台维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的Region。(比如当我有一个区域内存占用很高，但是回收过后发现里边的对象几乎都是可达的，这样代价很高！)
- 由于把这种侧重点在于回收垃圾最大量的区间，所以G1又叫：垃圾优先(Garbage First)













**synchronized**

两种实现方式

- 同步代码块

  ```java
  /*
  	1. 同步监视器俗称锁，他的要求比较宽泛，可以是任何一个对象，
  	   **但这个对象必须是多个线程共享的**
  	
  	2. 同步代码块就是操作数据资源的代码
  */
  synchronized(同步监视器){
      同步代码块
  }
  ```

  

- 同步方法

  ```java
  // 如果需要操作的数据都在一个方法里  那么可以把这个方法声明为synchronized方法
  
  // 当使用 public synchronized时，同步监视器是this，  
  // 使用 public static synchronized，同步监视器是 当前类.class
  public synchronized void test(){
  	同步代码块
  }
  
  
  ```



**wait() notify() notifyAll()**

1. 三个方法都是在java.lang.Object类里定义的

2. 三个方法都必须在同步代码块或者同步方法里使用
3. wait()  使当前线程进入阻塞状态，同时释放锁 
4. notify() notifyAll()  两个方法都是唤醒线程，前者唤醒优先级高的线程(相同则随机唤醒)，后者是唤醒所有线程
5. 只能针对同步监视器使用才有效。比如同步监视器里是this   但是三个方法都是Object实例来使用这就会出问题，只有同步监视器配套使用才线程通信。

**sleep() 与 wait()**

1. sleep() 与 wait()都能使线程进入阻塞状态
2. sleep()可以在任意地方使用，wait()只能在同步代码块和同步监视器使用
3. wait()会释放同步监视器锁，sleep()不会
4. sleep()在Thread类中声明，而wait()在Object中声明